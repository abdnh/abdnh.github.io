---
layout: post
title: "خوارزمية «ساحة تحويل السكك الحديدية» لحساب العبارات الرياضية"
tags: computer algorithms
uuid: 621bd7c1-2890-48a6-8579-4b36196530ce
---

خوارزمية [ساحة تحويل السكك الحديدية](https://www.youtube.com/watch?v=CE-7Qptga7c) ([Shunting-yard algorithm](https://en.wikipedia.org/wiki/Shunting-yard_algorithm))
هي خوارزمية يمكن استخدامها لتحليل العبارات الرياضية المكتوبة بالصيغة المعتادة المعروفة (مثل "5 + 3")،
والتي تدعى [ترميزا ضمنيا](https://ar.wikipedia.org/wiki/%D8%AA%D8%B1%D9%85%D9%8A%D8%B2_%D8%B6%D9%85%D9%86%D9%8A) ([Infix notation](https://en.wikipedia.org/wiki/Infix_notation))،
وتحويلها إلى عبارات مكتوبة بصيغة مثل <span dir="ltr">"5 3 +"</span>
حيث يكتب رمز كل عملية بعد [معاملاتها](https://ar.wikipedia.org/wiki/%D9%85%D8%B9%D8%A7%D9%85%D9%84_%D8%AD%D8%B3%D8%A7%D8%A8%D9%8A) (الأعداد) التي تعمل عليها.
تدعى هذه الصيغة الأخيرة ترميز بولنديا معكوسا ([Reverse Polish notation](https://en.wikipedia.org/wiki/Reverse_Polish_notation))

تعمل الخوارزمية بتوظيف بنية بيانات مشهورة وبسيطة وهي [المكدس](https://ar.wikipedia.org/wiki/%D9%85%D9%83%D8%AF%D8%B3_(%D8%A8%D9%86%D9%8A%D8%A9_%D8%A8%D9%8A%D8%A7%D9%86%D8%A7%D8%AA)) (stack)،
حيث تخزن مكدسين (مكدس "عمليات" ومكدس "مخرجات") وتحلل كل عملية ومعاملاتها وتضيفها إلى واحد من المكدسين بترتيب يراعي قواعد
أولوية العمليات المعروفة في الرياضيات[^1]. ينتج لدينا بعدها مكدس واحد غير فارغ (وهو مكدس المخرجات)
يمكن ببساطة إخراج العمليات منه بترتيب *من يدخل أخيراً يخرج أولاً* (Last-In-First-Out)‏
وإخراج معاملات كل عملية وإجراء العملية ثم إدخال النتيجة إلى المكدس مجددا واستخدامها كمعامل للعمليات المتبقية،
ليبقى لدينا في النهاية عدد واحد في مكدس المخرجات (بافتراض أن العبارة ليس فيها أي أخطاء) هو نتيجة العبارة الرياضية كلها.
كما يمكننا إنتاج عبارة جديدة بالصيغة البولندية المعكوسة من هذا المكدس بدون حساب النتيجة،
إذا كان ما يهمنا هو تحويل العبارة فقط وليس حساب نتيجتها.

## أمثلة

تعمل الخوارزمية على مكدسين اثنين كما قلنا: لندعُ الأول مكدس العمليات (operations)، والثاني مكدس المخرجات (output).
لنأخذ العبارة التالية البسيطة كمثال عن كيفية عمل الخوارزمية: "<code dir="ltr">3 + 7</code>".

1) نصادف أولا الرقم 3 ونضيفه إلى مكدس المخرجات.
{% highlight plaintext %}
operations: 
output: 3
{% endhighlight %}
2) ثم تأتي عملية الجمع فنضيفها إلى مكدس العمليات.
{% highlight plaintext %}
operations: +
output: 3
{% endhighlight %}
3) أخيرا يأتي الرقم 7 فنضيفه إلى مكدس المخرجات.
{% highlight plaintext %}
operations: +
output: 3 7
{% endhighlight %}
4) انتهينا من قراءة العبارة. الآن نخرج كل العمليات من مكدس العمليات بترتيب LIFO كما هو مبدأ عمل المكدس
  ونضيفها إلى مكدس المخرجات.
{% highlight plaintext %}
operations:
output: 3 7 +
{% endhighlight %}
5) تنتج لدينا العبارة التالية: "<code dir="ltr">3 7 +</code>"

لاحظ أننا أضفنا كل المعاملات (الأرقام) إلى مكدس المخرجات فور مصادفتنا لها،
بينما أضفنا عملية الجمع إلى مكدس العمليات ثم نقلناها إلى مكدس المخرجات بعد الانتهاء من قراءة
العبارة كلها. يمكننا بعدها إخراج كل عملية ومعاملاتها من مكدس المخرجات وحساب النتيجة وإدخال النتيجة
إلى المكدس مجددا لكي تشارك في حساب العمليات المتبقية (هنا ليس لدينا غير عملية واحدة).

-----
كان هذا مثالا بسيطا. لنأخذ مثالا أكثر تعقيدا بقليل: "<code dir="ltr">7 * 2 + 3</code>".

1) نضيف العدد 7 إلى مكدس المخرجات.
{% highlight plaintext %}
operations: 
output: 7
{% endhighlight %}
2) نضيف العملية * إلى مكدس العمليات.
{% highlight plaintext %}
operations: *
output: 7
{% endhighlight %}
3) نضيف العدد 2 إلى مكدس المخرجات.
{% highlight plaintext %}
operations: *
output: 7 2
{% endhighlight %}
4) نصل لعملية الجمع. في العادة سنضيفها إلى مكدس العمليات، لكن لأن هناك عملية قبلها
  لها أولوية أعلى (عملية الضرب)، فيجب نقل عملية الضرب إلى مكدس المخرجات أولا ثم فعل ذلك للحفاظ على ترتيب العمليات الصحيح.
{% highlight plaintext %}
operations: +
output: 7 2 *
{% endhighlight %}
5) نضيف بعدها العدد 3 إلى مكدس المخرجات.
{% highlight plaintext %}
operations: +
output: 7 2 * 3
{% endhighlight %}
6) انتهينا من قراءة العبارة. ننقل كل العمليات المتبقية من مكدس العمليات إلى مكدس المخرجات.
{% highlight plaintext %}
operations:
output: 7 2 * 3 +
{% endhighlight %}

كيف يمكننا حساب نتيجة العبارة الآن؟ ببساطة نخرج آخر عنصر من مكدس المخرجات (والذي
يجب أن يكون عملية وليس عددا إذا كانت العبارة صحيحة) ونخرج أعدادا من المعاملات الموجودة
بعده في المكدس حسب عدد المعاملات التي تأخذها العملية (ستكون معلومات كل عملية من
أولوية وعدد معاملات مخزنةً مسبقا لدينا) ثم نجري العملية.
في مثالنا هذا سنخرج عملية الجمع والعدد 3 بعدها، لكن عملية الجمع تأخذ معاملين والعنصر
بعد 3 ليس عددا بل عملية الضرب، فما العمل هنا؟ ما سنفعله هنا هو حساب العملية الأخرى
التي صادفناها (الضرب) بالطريقة نفسها واستخدام نتيجتها كمعامل للجمع بجانب العدد 3.
بهذا الشكل نكون قد أجرينا العمليات بترتيب صحيح. بعد حساب عملية الضرب يصبح المكدس
بهذا الشكل:
{% highlight plaintext %}
operations:
output: 14 3 +
{% endhighlight %}
نجري الآن عملية الجمع لنحصل على 17 كناتج نهائي للعبارة.

-----
لنأخذ عبارة شبيهة لكن هذه المرة مع أقواس لنرى كيف تتعامل معها الخوارزمية: "<code dir="ltr">7 * (2 + 3)</code>".

1) نضيف العدد 7 إلى مكدس المخرجات.
{% highlight plaintext %}
operations: 
output: 7
{% endhighlight %}
2) نضيف العملية * إلى مكدس العمليات.
{% highlight plaintext %}
operations: *
output: 7
{% endhighlight %}
3) نضيف القوس الأيسر ")" إلى مكدس العمليات:
{% highlight plaintext %}
operations: * (
output: 7
{% endhighlight %}
4) نضيف العدد 2 إلى مكدس المخرجات.
{% highlight plaintext %}
operations: * (
output: 7 2
{% endhighlight %}
5) نأتي لعملية الجمع. في المثال السابق نظرنا إلى آخر عملية في مكدس العمليات (الضرب) وقررنا 
أن ننقلها إلى مكدس المخرجات لأن لها أولوية أعلى من الجمع. هذه المرة نصادف القوس الأيسر، فما العمل؟
في هذه الحالة، نضيف العملية الحالية (الجمع) إلى مكدس العمليات ونستمر بقراءة العبارة ببساطة.
{% highlight plaintext %}
operations: * ( +
output: 7 2
{% endhighlight %}
6) نضيف العدد 3 إلى مكدس المخرجات.
{% highlight plaintext %}
operations: * ( +
output: 7 2 3
{% endhighlight %}
8) نصادف القوس الأيمن "(". لا نضيفه لأي من المكدسات، بل نبدأ بإخراج عمليات من مكدس
العمليات وننقلها إلى مكدس المخرجات حتى نصادف قوسا أيسر ")" أو يصبح مكدس العمليات فارغا
تماما بدون أن نجد قوسا أيسر (في هذه الحالة هناك قوس ناقص يمكننا إعلام المستخدم عنه).
بفرض أننا وجدنا قوسا أيسر، نخرجه من مكدس العمليات ونتخلص منه.
{% highlight plaintext %}
operations: *
output: 7 2 3 +
{% endhighlight %}
9) انتهينا من قراءة العبارة. ننقل كل العمليات المتبقية من مكدس العمليات إلى مكدس المخرجات.
{% highlight plaintext %}
operations:
output: 7 2 3 + *
{% endhighlight %}

إذا نردنا حساب النتيجة فسنتبع الخطوات التالية:

1) نبدأ بعملية الضرب ونجد أنها تعتمد على عملية قبلها وهي عملية الجمع.
<div dir="ltr">7 <span style="text-decoration: underline;">2 3 +</span> *</div>

2) نحسب عملية الجمع ("<code dir="ltr">2 3 +</code>") لنحصل على العبارة التالية:
<div dir="ltr"><span style="text-decoration: underline;">7</span> <span style="text-decoration: underline;">5</span> *</div>

3) حصلنا على معاملات عملية الضرب العددية. نجري الآن العملية لنحصل على 35 كناتج نهائي.

-----
لنأخذ مثالا آخر يوضح فكرة مهمة قد يسهو عنها من يريد تطبيق الخوارزمية (مثلي): "<code dir="ltr">5 - 2 - 2</code>"

1) نضيف العدد 5 إلى مكدس المخرجات.
{% highlight plaintext %}
operations:
output: 5
{% endhighlight %}
2) نضيف عملية الطرح إلى مكدس العمليات.
{% highlight plaintext %}
operations: -
output: 5
{% endhighlight %}
3) نضيف العدد 2 إلى مكدس المخرجات.
{% highlight plaintext %}
operations: -
output: 5 2
{% endhighlight %}
4) نأتي لعملية الطرح الثانية. ننظر لآخر عملية في مكدس العمليات ونجد العملية نفسها، لذلك فأولويات العمليتين متساويتان طبعا.
ما العمل الآن؟ هل (1) نضيف العملية الحالية إلى مكدس العمليات أم (2) يجب أولا أن ننقل العملية السابقة
من مكدس العمليات إلى مكدس المخرجات ثم نفعل ذلك؟
فكر بما سيحدث في كلا الحالتين وجرب رسم حالة المكدسين كما نفعل هنا على ورقة قبل الاستمرار بالقراءة.

دعنا نجرب كلا الخيارين ونرى:

إذا اخترنا (1) فسننتهي بالعبارة البولندية المعكوسة "<code dir="ltr">5 2 2 - -</code>".

إذا اخترنا (2) فستنتج العبارة "<code dir="ltr">5 2 - 2 -</code>".

ناتج (1) هو 5 بينما ناتج (2) هو 1. من البديهي أن الخيار (2) هو الصحيح حسب قواعد الرياضيات المعتادة.

عبارة "<code dir="ltr">5 - 2 - 2</code>" في الحقيقة يتم تحليلها كأنها كتبت "<code dir="ltr">(5 - 2) - 2</code>".

هناك عمليات مثل الطرح والقسمة تعارف الناس على حسابها بهذا الشكل، حيث يتم تجميع عوامل كل عملية بدءًا من اليسار،
بينما هناك عمليات تُحسَب من اليمين (كما سنرى لاحقا). يعرف مفهوم اتجاه إجراء العمليات المتطابقة
باسم «ترابط العمليات» ([operator associativity](https://en.wikipedia.org/wiki/Operator_associativity))
في لغات البرمجة. تدعى عمليات مثل الطرح والقسمة left-associative operators،
بينما يقال لعمليات تُجمَّع من اليمين إلى اليسار إنها right-associative operators.

ستصبح المكدسات بهذا الشكل بعد أن تعرفنا على فكرة ترابط العمليات ونقلنا عملية الطرح السابقة
من مكدس العمليات إلى مكدس المخرجات ثم أضفنا عملية الطرح الثانية الحالية إلى مكدس العمليات:
{% highlight plaintext %}
operations: -
output: 5 2 -
{% endhighlight %}

لنستمر بتحليل العبارة:

5) نضيف العدد 2 إلى مكدس المخرجات.
{% highlight plaintext %}
operations: -
output: 5 2 - 2
{% endhighlight %}

6) انتهينا من قراءة العبارة. ننقل كل العمليات من مكدس العمليات إلى مكدس المخرجات لنحصل على:
{% highlight plaintext %}
operations:
output: 5 2 - 2 -
{% endhighlight %}

-----
لنأخذ مثالا آخر يوضح فكرة ترابط العمليات أكثر: "<code dir="ltr">2^2^3</code>"
(يدل `^` هنا على عملية [الرفع إلى أس](https://ar.wikipedia.org/wiki/%D8%B1%D9%81%D8%B9_(%D8%B1%D9%8A%D8%A7%D8%B6%D9%8A%D8%A7%D8%AA)))

1) نضيف العدد 2 إلى مكدس المخرجات.
{% highlight plaintext %}
operations:
output: 2
{% endhighlight %}
2) نضيف العملية ^ إلى مكدس العمليات.
{% highlight plaintext %}
operations: ^
output: 2
{% endhighlight %}
3) نضيف العدد 2 إلى مكدس المخرجات.
{% highlight plaintext %}
operations: ^
output: 2 2
{% endhighlight %}
4) نأتي لعملية الرفع إلى أس الثانية. ننظر لآخر عملية في مكدس العمليات ونجد العملية نفسها، لذلك فأولويات العمليتين متساويتان.
في المثال السابق نقلنا آخر عملية في مكدس العمليات إلى مكدس المخرجات لأن عملية الطرح left-associative،
لكن هل عملية الرفع إلى أس كذلك؟ غالبا لا، عملية الرفع إلى أس تعمل من اليمين إلى اليسار، أي <span dir="ltr">right-associative</span>.[^2]
هذا يعني أن عبارة "<code dir="ltr">2^2^3</code>" يتم تحليلها كـ "<code dir="ltr">2^(2^3)</code>".
لذلك سنضيف العملية الحالية إلى مكدس العمليات ونستمر ببساطة.
{% highlight plaintext %}
operations: ^ ^
output: 2 2
{% endhighlight %}
5) نضيف العدد 3 إلى مكدس المخرجات.
{% highlight plaintext %}
operations: ^ ^
output: 2 2 3
{% endhighlight %}
6) انتهينا من قراءة العبارة. ننقل كل العمليات من مكدس العمليات إلى مكدس المخرجات.
{% highlight plaintext %}
operations:
output: 2 2 3 ^ ^
{% endhighlight %}

نتجت لدينا العبارة البولندية المعكوسة "<code dir="ltr">2 2 3 ^ ^</code>" والتي ناتجها هو 256،
بينما لو عاملنا عملية الرفع إلى أس على أنها left-associative فستنتج العبارة "<code dir="ltr">2 2 ^ 3 ^</code>"
والتي ناتجها هو 64.

## استعراض تفاعلي للخوارزمية

استخدم هذا البرنامج التفاعلي المضمن لفهم الخوارزمية أكثر . جرب إدخال عبارة رياضية ما والضغط على «تشغيل»
لكي يحسبه البرنامج، ثم اضغط «إيقاف» واستخدم خياري «التقدم بخطوة» و«الرجوع بخطوة» لفحص عمل الخوارزمية خطوة بخطوة.

{::nomarkdown}
<iframe src="https://www.abdnh.net/shunting-yard-algorithm-demo/?lang=ar"></iframe>
{:/}

اضغط على هذا الرابط إذا كانت نافذة البرنامج لا تظهر كليا أو هناك مشكلة في عرضها: <https://www.abdnh.net/shunting-yard-algorithm-demo/?lang=ar>

## خطوات عمل الخوارزمية

بعد أن نظرنا إلى عدة أمثلة، يمكننا استنتاج خطوات عمل الخوارزمية وكتابتها بشكل شبه منهجي على
النحو التالي:

1) نقرأ حدا من حدود العبارة الرياضية المدخلة إذا كان ما يزال هناك حدود.

2) إذا كان الحد عددا نضيفه إلى مكدس المخرجات

3) إذا كان الحد عملية غير الأقواس (لنقل لها O<sub>1</sub>)، نبدأ بنقل كل عملية O<sub>2</sub> من مكدس العمليات
  إلى مكدس المخرجات ما دامت (1) ليست أقواسا **و** (2) أولويتها أعلى من أولوية O<sub>1</sub> **أو**
  للعمليتين أولويات متساوية **و** عملية O<sub>1</sub> هي left-associative، ثم ندخل O<sub>1</sub>
  إلى مكدس العمليات. يمكن التعبير عن الشرط بال[سودوكود](https://ar.wikipedia.org/wiki/%D8%B3%D9%88%D8%AF%D9%88%D9%83%D9%88%D8%AF):
{% highlight plaintext %}
(o2 is not a parenthesis) AND ((o2.precedence > o1.precedence) OR (o2.precedence == o1.precedence && o1 is left-associative))
{% endhighlight %}

4) إذا كان الحد قوسا أيسر ")"، نضيفه إلى مكدس العمليات.

5) إذا كان الحد قوسا أيمن "("،نبدأ بنقل عمليات من مكدس العمليات إلى مكدس المخرجات ما
  دامت ليست أقواسا يسرى، ثم نخرج القوس الأيسر من مكدس العمليات وتخلص منه. إذا لم يوجد
  قوس أيسر فهناك خطأ في العبارة.

6) بعد الانتهاء من قراءة كل حدود العبارة، ننقل كل العمليات من مكدس العمليات إلى مكدس المخرجات.

ينتج لدينا في مكدس المخرجات عبارة رياضية بالصيغة البولندية المعكوسة بعد هذه العملية.
إذا كان هدفنا هو حساب ناتج العملية وليس إنتاج عبارة بصيغة مختلفة، فبدل عملية نقل العمليات
إلى مكدس المخرجات المتكررة في عدة خطوات (3، 5، 6)، يمكننا ببساطة إخراج عوامل كل
عملية من هذه العمليات وحساب ناتجها وإضافته إلى مكدس المخرجات.


## تطبيق للخوارزمية

لتطبيق للخوارزمية بلغة C، انظر هذه المكتبة التي كتبتها: <https://github.com/abdnh/math-eval>

## وصلات خارجية

سأضع هنا وصلات إنترنت للاستزادة أكثر حول الموضوع:

- فيديوهات يوتيوب على قناة Computerphile:
  - [Reverse Polish Notation and The Stack](https://www.youtube.com/watch?v=7ha78yWRDlE)
  - [Reverse Polish Grows on Trees](https://www.youtube.com/watch?v=TrfcJCulsF4)

[^1]: انظر [ويكيبيديا](https://ar.wikipedia.org/wiki/%D8%AA%D8%B1%D8%AA%D9%8A%D8%A8_%D8%A7%D9%84%D8%B9%D9%85%D9%84%D9%8A%D8%A7%D8%AA_%D8%A7%D9%84%D8%AD%D8%B3%D8%A7%D8%A8%D9%8A%D8%A9#%D8%AA%D8%B1%D8%AA%D9%8A%D8%A8_%D9%85%D8%B3%D8%AA%D9%88%D9%89_%D8%A7%D9%84%D8%B9%D9%85%D9%84%D9%8A%D8%A7%D8%AA) حول ترتيب العمليات.

[^2]: ليس هناك في الحقيقة إجماع حول هذه القاعدة لكن يبدو أن الحساب من اليمين (right-associative) هو الشائع بين لغات البرمجة. انظر <https://codeplea.com/exponentiation-associativity-options> لمزيد من التفاصيل.
