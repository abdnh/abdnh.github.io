<!DOCTYPE html>
<html lang="ar" dir="rtl">



<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>&#8295;خوارزمية الترتيب بالعد - مدونة عبدو الفضولية&#8297;</title>
    <link rel="stylesheet" type="text/css" href="/css/main.css">
    <link rel="alternate" type="application/atom+xml" href="feed.atom" title="Atom Feed">
    <link rel="icon" type="image/png" href="/favicon.png">
    
</head>


<body>
    <div id="sidebar">
    <a href="/"><img src="/favicon.png" id="logo" alt="شعار المدونة؛ فضولي" width="64" height="64" ontransitionend="if(window.event.elapsedTime >= 5) window.location = '/fuduli';"></a>
    <ul id="nav-links">
        <li><a id="about" href="/about">حول</a></li>
        <li><a id="projects" href="/projects">مشاريع</a></li>
        <li><a id="wiki" href="/wiki/">ويكي</a></li>
    </ul>
</div>
    <main>
        <div id="post">
	<header id="post-header">
		
		<h1>خوارزمية الترتيب بالعد</h1>
		
		<div id="post-meta">
			<div>
				<time datetime="2021-08-19" title="تاريخ الإنشاء">2021-08-19</time>
				
				|
				<a href="https://github.com/abdnh/abdnh.github.io/commits/master/_posts/2021-08-19-counting-sort.md"><time datetime="2021-10-16" title="آخر تعديل">2021-10-16</time></a>
				
			</div>
			<div id="tags">
				
				<a href="/tag/computer">حاسوب</a>
				
				<a href="/tag/algorithms">خوارزميات</a>
				
			</div>
		</div>
	</header>
	<article>
		
		<p>خوارزمية الترتيب بالعد هي <a href="https://ar.wikipedia.org/wiki/%D8%AE%D9%88%D8%A7%D8%B1%D8%B2%D9%85%D9%8A%D8%A9_%D8%AA%D8%B1%D8%AA%D9%8A%D8%A8">خوازمية ترتيب</a>
للأعداد الصحيحة.</p>

<p>ترتّب الخوارزمية مصفوفة أعداد عن طريق إحصاء مرات تكرار كل عدد وتخزن هذه المعلومات
في مصفوفة جديدة (لنقل لها مصفوفة الإحصاء). ثم تحسب موضع كل عنصر
من مصفوفة المدخلات في مصفوفة المخرجات المرتبة باستخدام مصفوفة الإحصاء.</p>

<p>مع أن الخوارزمية متخصصة بالأعداد الصحيحة، يمكن تكييفها لترتيب مصفوفة من أي نوع من البيانات
ما دام لكل عنصر عدد صحيح متعلق به يمكن استخدامه كـ”مفتاح” وترتيبه.</p>

<h2 id="مثال">مثال</h2>

<p>لنأخذ مثالا لتوضيح كيفية عمل الخوارزمية بتفصيل أكثر:
لنقل أننا نريد ترتيب سلسلة الحروف “the quick brown fox jumps over the lazy dog”
تصاعديا حسب قيم <a href="https://ar.wikipedia.org/wiki/%D8%A3%D8%B3%D9%83%D9%8A">ASCII</a> العددية لحروفها.</p>

<p>سترتب الخوارزمية هذه السلسلة بهذه الخطوات:</p>

<p>1) نبدأ بحساب نطاق المفاتيح (الفرق بين أكبر وأصغر عنصر، لنسمه <code class="language-plaintext highlighter-rouge">range</code>) في مصفوفة الحروف لكي نستطيع
  حجز مساحة كافية لمصفوفة الإحصاء (لنسمها <code class="language-plaintext highlighter-rouge">count</code>). كما نبحث عن أصغر مفتاح أيضا لكي نستخدمه في فهرسة
  مصفوفة الإحصاء مع السماح بمفاتيح لا تبدأ بالصفر (نستخدم <code class="language-plaintext highlighter-rouge">count[key - offset]</code>
  للوصول إلى عدد مرات تكرار العنصر صاحب المفتاح <code class="language-plaintext highlighter-rouge">key</code> حيث <code class="language-plaintext highlighter-rouge">offset</code> هو أصغر مفتاح).
  سنحصل على القيم التالية بعد معالجة سلسلة الحروف: <code class="language-plaintext highlighter-rouge">offset = 32</code> و <code class="language-plaintext highlighter-rouge">range = 91</code>.
  تأكد من أن هذه القيم صحيحة بنفسك باستخدام <a href="https://ar.wikipedia.org/wiki/%D8%A3%D8%B3%D9%83%D9%8A#%D9%82%D8%A7%D8%A6%D9%85%D8%A9_%D8%A7%D9%84%D8%B1%D9%85%D9%88%D8%B2">جدول ASCII الموجود في هذه الصفحة</a>
  (لا تنسَ أخذ حرف المسافة بعين الاعتبار).</p>

<p>2) نملأ الآن مصفوفة الإحصاء بمرات تكرار كل مفتاح لنحصل على مصفوفة بهذا الشكل:</p>

<figure class="highlight"><pre><code class="language-plaintext" data-lang="plaintext">i:        0 1 2 ...  65  66  67  68  69  70  71  72  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90
count[i]: 8 0 0 ...   1   1   1   1   3   1   1   2   1   1   1   1   1   1   4   1   1   2   1   2   2   1   1   1   1   1</code></pre></figure>

<p>3) لكل فهرس <code class="language-plaintext highlighter-rouge">i</code> في مصفوفة الإحصاء، نجري العملية <code class="language-plaintext highlighter-rouge">count[i] += count[i - 1]</code>.
  بعد هذا، سيحمل <code class="language-plaintext highlighter-rouge">count[i]</code> الفهرس الأكبر بواحد من فهرس آخر عنصر بمفتاح <code class="language-plaintext highlighter-rouge">i + offset</code>
  في المصفوفة المرتبة النهائية. ستصبح مصفوفة الإحصاء بهذا الشكل الآن:</p>

<figure class="highlight"><pre><code class="language-plaintext" data-lang="plaintext">i:        0 1 2 ...  65  66  67  68  69  70  71  72  73  74  75  76  77  78  79  80  81  82  83  84  85  86  87  88  89  90
count[i]: 8 8 8 ...   9  10  11  12  15  16  17  19  20  21  22  23  24  25  29  30  31  33  34  36  38  39  40  41  42  43</code></pre></figure>

<p>4) نفحص سلسلة الحروف مجددا، لكن هذه المرة من آخرها إلى أولها (لضمان <a href="https://ar.wikipedia.org/wiki/%D8%AE%D9%88%D8%A7%D8%B1%D8%B2%D9%85%D9%8A%D8%A9_%D8%AA%D8%B1%D8%AA%D9%8A%D8%A8#%D9%85%D9%85%D9%8A%D8%B2_%D8%A7%D9%84%D8%AB%D8%A8%D8%A7%D8%AA">الثبات</a>).
  نستخرج مفتاح كل عنصر، وننقص عداد العنصر الموجود في مصفوفة الإحصاء بواحد،
  ثم نخزن العنصر في موقعه الجديد في المصفوفة المرتبة باستخدام عداده في مصفوفة الإحصاء.
  بـ<a href="https://ar.wikipedia.org/wiki/%D8%B3%D9%88%D8%AF%D9%88%D9%83%D9%88%D8%AF">السودوكود</a> كما هو معطى في <a href="https://en.wikipedia.org/wiki/Counting_sort#Pseudocode">ويكيبديا الإنجليزية</a>:</p>

<figure class="highlight"><pre><code class="language-plaintext" data-lang="plaintext">for i = length(input) - 1 downto 0 do
    j = key(input[i])
    count[j] -= 1
    output[count[j]] = input[i]</code></pre></figure>

<p>5) لقد انتهينا! لدينا الآن سلسلة حروف مرتبة:</p>

<figure class="highlight"><pre><code class="language-plaintext" data-lang="plaintext">'        abcdeeefghhijklmnoooopqrrsttuuvwxyz'</code></pre></figure>

<p>من ميزات هذه الخوارزمية أنها لا تعتمد على مبدأ المقارنة بين العناصر المراد ترتيبها المستخدم
بشيوع في خوارزميات ترتيب عديدة مثل Quicksort و Merge sort وغيرها.
هذا لأنها مخصصة لترتيب الأعداد الصحيحة والتي يمكن معاملتها كفهارس (indices)
وإيجاد ترتيبها الصحيح بدون الحاجة للمقارنات. تمنح هذه الميزة للخوارزمية
<a href="https://ar.wikipedia.org/wiki/%D8%AA%D8%B9%D9%82%D9%8A%D8%AF_%D8%A7%D9%84%D9%88%D9%82%D8%AA#%D8%A7%D9%84%D9%88%D9%82%D8%AA_%D8%A7%D9%84%D8%AE%D8%B7%D9%8A">تعقيدا زمنيا خطيا</a>
لا تستطيع الخوارزميات الأخرى المعتمدة على المقارنة تجاوزه لأن حدها السفلي O(n log n) رياضيا.<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></p>

<p>تحتاج الخوارزمية لمساحة O(n + k) حيث n عدد العناصر في مصفوفة المدخلات و k نطاق العناصر.
تأتي n من حقيقة أن الخوارزمية لا تغير البيانات الموجودة في مصفوفة المدخلات بل تنشئ مصفوفة جديدة وتنسخ المدخلات المرتبة إليها.
هذا ضروري لضمان <a href="https://ar.wikipedia.org/wiki/%D8%AE%D9%88%D8%A7%D8%B1%D8%B2%D9%85%D9%8A%D8%A9_%D8%AA%D8%B1%D8%AA%D9%8A%D8%A8#%D9%85%D9%85%D9%8A%D8%B2_%D8%A7%D9%84%D8%AB%D8%A8%D8%A7%D8%AA">الثبات</a>،
(الترتيب النسبي للعناصر المتساوية). يمكن تبسيط الخوارزمية وجعلها لا تحتاج إلّا إلى O(k) مساحة،
لكن هذا يجعلها غير ثابتة ولا يجعلها مفيدة لأكبر مجال استخدام لها وهو كدالة فرعية في خوارزمية ترتيب
أخرى تدعى <a href="https://en.wikipedia.org/wiki/Radix_sort">Radix sort</a>.
تأتي مساحة k من مصفوفة الإحصاء التي نخزن فيها مرات تكرار كل عدد من مصفوفة المدخلات.
يجب أن تكون هذه المصفوفة كبيرة كفاية لتشمل كل نطاق الأعداد المدخلة فمبدأ عمل الخوارزمية
يعتمد على ذلك. يُفضَّل استخدام خوارزمية الترتيب بالعد عندما لا تكون قيمة k أكبر من قيمة n بكثير، وإلا قد
يكون استخدام خوارزميات أخرى أكثر فعالية عندما تكون k أكبر بكثير من n.</p>

<h2 id="استعراض-تفاعلي-للخوارزمية">استعراض تفاعلي للخوارزمية</h2>

<p>استخدم هذا البرنامج التفاعلي المضمن لفهم الخوارزمية أكثر . جرب إدخال بعض الأرقام أو الكلمات والضغط على «تشغيل»
لكي يرتبها البرنامج، ثم اضغط «إيقاف» واستخدم خياري «التقدم بخطوة» و«الرجوع بخطوة» لفحص عمل الخوارزمية خطوة بخطوة.</p>

<iframe src="https://www.abdnh.net/counting-sort-demo/?lang=ar" allow="fullscreen"></iframe>

<p>اضغط على هذا الرابط إذا كانت نافذة البرنامج لا تظهر كليا أو هناك مشكلة في عرضها: <a href="https://www.abdnh.net/counting-sort-demo/?lang=ar">https://www.abdnh.net/counting-sort-demo/?lang=ar</a></p>

<h2 id="تطبيق-للخوارزمية">تطبيق للخوارزمية</h2>

<p>في الأسفل تطبيق للخوارزمية في لغة C:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
</pre></td><td class="code"><pre><span class="cp">#include</span> <span class="cpf">&lt;limits.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdbool.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="n">item</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="n">key</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">bool</span> <span class="nf">counting_sort</span><span class="p">(</span><span class="k">struct</span> <span class="n">item</span> <span class="n">array</span><span class="p">[],</span> <span class="kt">unsigned</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// احسب النطاق وأصغر مفتاح</span>
    <span class="kt">unsigned</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">UINT_MAX</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="n">key</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&lt;</span> <span class="n">offset</span><span class="p">)</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">key</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">unsigned</span> <span class="n">range</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">// احجز مساحة للمصفوفة المرتبة ومصفوفة الإحصاء</span>
    <span class="k">struct</span> <span class="n">item</span> <span class="o">*</span><span class="n">sorted</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">item</span><span class="p">)</span> <span class="o">*</span> <span class="n">length</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sorted</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="n">calloc</span><span class="p">(</span><span class="n">range</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">free</span><span class="p">(</span><span class="n">sorted</span><span class="p">);</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// احسب مرات تكرار كل مفتاح</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">count</span><span class="p">[</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span> <span class="o">-</span> <span class="n">offset</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// احسب موضع عناصر كل مفتاح في المصفوفة المرتبة</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">range</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">count</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">count</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="c1">// ضع كل عنصر في موضعه في المصفوفة المرتبة</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">UINT_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="n">j</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
        <span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
        <span class="n">sorted</span><span class="p">[</span><span class="n">count</span><span class="p">[</span><span class="n">j</span><span class="p">]]</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="c1">// انسخ النتيجة النهائية إلى المصفوفة المدخلة وحرر المساحة التي حجزناها مسبقا</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">sorted</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">array</span><span class="p">)</span> <span class="o">*</span> <span class="n">length</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">sorted</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">count</span><span class="p">);</span>

    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">item</span> <span class="n">array</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{{.</span><span class="n">data</span> <span class="o">=</span> <span class="s">"foo"</span><span class="p">},</span>
                           <span class="p">{.</span><span class="n">data</span> <span class="o">=</span> <span class="s">"bar"</span><span class="p">},</span>
                           <span class="p">{.</span><span class="n">data</span> <span class="o">=</span> <span class="s">"ah"</span><span class="p">},</span>
                           <span class="p">{.</span><span class="n">data</span> <span class="o">=</span> <span class="s">"spam"</span><span class="p">},</span>
                           <span class="p">{.</span><span class="n">data</span> <span class="o">=</span> <span class="s">"oh"</span><span class="p">}};</span>
    <span class="kt">unsigned</span> <span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span> <span class="o">=</span> <span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">)[</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">counting_sort</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">length</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">fputs</span><span class="p">(</span><span class="s">"out of memory</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">stderr</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"key = %u , data = '%s'</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">key</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>لتطبيق أعم وأكثر مرونة، اطلع على هذه المكتبة البسيطة التي كتبتها: <a href="https://github.com/abdnh/counting-sort">https://github.com/abdnh/counting-sort</a></p>

<h2 id="مصادر">مصادر</h2>

<ul>
  <li>استعراض مرئي آخر للترتيب بالعد: <a href="https://www.cs.usfca.edu/~galles/visualization/CountingSort.html">https://www.cs.usfca.edu/~galles/visualization/CountingSort.html</a></li>
  <li>شرح آخر للخوارزمية على موسوعة حسوب: <a href="https://wiki.hsoub.com/Algorithms/counting_sort">https://wiki.hsoub.com/Algorithms/counting_sort</a></li>
</ul>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>انظر <a href="https://en.wikipedia.org/wiki/Comparison_sort#Performance_limits_and_advantages_of_different_sorting_techniques">Comparison sort</a> في ويكيبيديا الإنجليزية. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

	</article>
</div>

    </main>
    <footer id="footer" dir="ltr">
  <ul id="footer-links">
    <li>
      <a rel="alternate" type="application/atom+xml" href="feed.atom"
        ><svg
          xmlns="http://www.w3.org/2000/svg"
          width="24"
          height="24"
          fill="currentColor"
          class="bi bi-rss"
          viewBox="0 0 16 16"
        >
          <path
            d="M14 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"
          />
          <path
            d="M5.5 12a1.5 1.5 0 1 1-3 0 1.5 1.5 0 0 1 3 0zm-3-8.5a1 1 0 0 1 1-1c5.523 0 10 4.477 10 10a1 1 0 1 1-2 0 8 8 0 0 0-8-8 1 1 0 0 1-1-1zm0 4a1 1 0 0 1 1-1 6 6 0 0 1 6 6 1 1 0 1 1-2 0 4 4 0 0 0-4-4 1 1 0 0 1-1-1z"
          /></svg
      ></a>
    </li>
    <li>
      <a href="mailto:abdo@abdnh.net"
        ><svg
          xmlns="http://www.w3.org/2000/svg"
          width="24"
          height="24"
          fill="currentColor"
          class="bi bi-envelope"
          viewBox="0 0 16 16"
        >
          <path
            d="M0 4a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2V4Zm2-1a1 1 0 0 0-1 1v.217l7 4.2 7-4.2V4a1 1 0 0 0-1-1H2Zm13 2.383-4.708 2.825L15 11.105V5.383Zm-.034 6.876-5.64-3.471L8 9.583l-1.326-.795-5.64 3.47A1 1 0 0 0 2 13h12a1 1 0 0 0 .966-.741ZM1 11.105l4.708-2.897L1 5.383v5.722Z"
          /></svg
      ></a>
    </li>
    <li>
      <a href="https://github.com/abdnh/abdnh.github.io"
        ><svg
          xmlns="http://www.w3.org/2000/svg"
          width="24"
          height="24"
          fill="currentColor"
          class="bi bi-code"
          viewBox="0 0 16 16"
        >
          <path
            d="M5.854 4.854a.5.5 0 1 0-.708-.708l-3.5 3.5a.5.5 0 0 0 0 .708l3.5 3.5a.5.5 0 0 0 .708-.708L2.707 8l3.147-3.146zm4.292 0a.5.5 0 0 1 .708-.708l3.5 3.5a.5.5 0 0 1 0 .708l-3.5 3.5a.5.5 0 0 1-.708-.708L13.293 8l-3.147-3.146z"
          /></svg
      ></a>
    </li>
  </ul>
</footer>

</body>

</html>
